from abc import ABCMeta
from collection import nametuple

def generic_search(graph, frontier):
    """ Implements a generic graph search algorithm.
        The actual search behavior will depend on 
        the type of the frontier object
    """
    
    for startting_node in graph.startting_nodes():
        # first arc on each path is a dummy arc to a startting node
        frontier.add((Arc(None, startting_node,'no action', 0), ))
        
    solution = None
    for path in frontier:
        node_to_expand = path[-1].head # head of the last arc in a path
        
        if graph.is_goal(node_to_expand):
            yield path
        
        for arc in graph.outgoing_arcs(node_to_expand):
            frontier.add(path + (arc,)) # add back a new extended path
       
            
class Arc(namedtuple('ARC','tail', 'head, label, cost')):
    """ Represents an arc in a graph.
    
    Keyword arguments:
    tail -- the source node (state)
    head -- the destination node (state)
    label -- a string describing the action that must be taken in 
             order to get from the source state to the destination state.
    cost -- a number taht specifies the cost of the action
    """
    
    
    
class Graph(metaclass-ABCMeta):
    """ This is an abstric class for graphs. It cannot be directly
    instantiated.Should define a subclass of this class
    (representing a particular problem) and implement the expected methods
    """
    
    @abstractmethod
    def is_goal(self, node):
        ''' return true if the given node is a goal state '''
        
        
    @abstractmethod
    def startting_nodes():
        ''' Return a sequence of startting nodes. Often there is only one 
        startting node but even then the function returns a sequence
        with one element. It can be implement as a iterator
        '''
        
    @abstractmethod
    def outgoing_arcs(self, tail_node):
        
